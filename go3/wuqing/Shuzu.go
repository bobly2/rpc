package wuqing

import "fmt"

func test() {

	//假如我们只想给索引为1和3的数组初始化相应的值，其他都为0怎么做呢，
	arr := [5]int{1: 1, 3: 4}
	fmt.Printf("%d", arr[1])

	for i, v := range arr {
		fmt.Printf("索引:%d,值:%d\n", i, v)
	}
	x:=new(int)
	fmt.Printf("索引:%d,值:%d\n", x)
	//长度相同的数组可以直接复制
	//var array1 [5]int = arr //success

	//指针数组和数组本身差不多，只不过元素类型是指针。
	arrp := [5]*int{1:new(int),3:new (int)}
	//并且为索引1和3都创建了内存空间，其他索引是指针的零值nil,这时候我们要修改指针变量的值也很简单，如下即可：
	*arrp[1]=1
	//以上需要注意的是，只可以给索引1和3赋值，因为只有它们分配了内存，才可以赋值，
	//如果我们给索引0赋值，运行的时候，会提示无效内存或者是一个nil指针引用。

	//要解决这个问题，我们要先给索引0分配内存，然后再进行赋值修改。
	arrp[0] =new(int)
	*arrp[0] = 2



}


//函数间传递数组
//在函数间传递变量时，总是以值的方式，如果变量是个数组，那么就会整个复制，
//并传递给函数，如果数组非常大，比如长度100多万，那么这对内存是一个很大的开销。

//有一种办法是传递数组的指针，这样，复制的大小只是一个数组类型的指针大小。
//这是传递数组的指针的例子，会发现数组被修改了。所以这种情况虽然节省了复制的内存，但是要谨慎使用，
//因为一不小心，就会修改原数组，导致不必要的问题。

//这里注意，数组的指针和指针数组是两个概念，数组的指针是*[5]int,指针数组是[5]*int，注意*的位置。
func Test2() {
	slice := []int{1, 2, 3, 4, 5}
	fmt.Printf("%p\n", &slice)
	modify(slice)
	fmt.Println(slice)
}

func modify(slice []int) {
	fmt.Printf("%p\n", &slice)
	slice[1] = 10
}
