package wuqing

import "fmt"

func Qp() {
	//切片也是一种数据结构，它和数组非常相似，因为他是围绕动态数组的概念设计的，可以按需自动改变大小，arraylist
	//它的底层的内存是连续非配的
	//它是只有3个字段的数据结构：一个是指向底层数组的指针，一个是切片的长度，一个是切片的容量
	//slice:=make([]int,5)
	//这时候切片的容量是5

	//slice:=make([]int,5,10)
	//创建的切片长度是5，容量是10,
	//因为切片的底层是数组，所以创建切片时，如果不指定字面值的话，默认值就是数组的元素的零值

	//这里我们所以指定了容量是10，但是我们只能访问5个元素，因为切片的长度是5，剩下的5个元素，需要切片扩充后才可以访问。
	//容量必须>=长度，我们是不能创建长度大于容量的切片的

	//slice3:=[]int{1,2,3,4,5}
	//当然我们也可以像数组一样，只初始化某个索引的值：
	//slice4:=[]int{4:1}

	//切片还有nil切片和空切片，它们的长度和容量都是0，但是它们指向底层数组的指针不一样，
	//nil切片意味着指向底层数组的指针为nil，
	//空切片对应的指针是个地址。

	//nil切片
	//var nilSlice []int
	//空切片
	//slice5:=[]int{}
	//nil切片表示不存在的切片，而空切片表示一个空集合，它们各有用处。

	//基于现有的数组或者切片创建。
	//基于现有的切片或者数组创建，使用[i:j]这样的操作符即可，
	//她表示以i索引开始，到j索引结束,截取原数组或者切片
	//，创建而成的新切片，新切片的值包含原切片的i索引，但是不包含j索引
	slice := []int{1, 2, 3, 4, 5}
	slice1 := slice[:]
	slice2 := slice[0:]
	slice3 := slice[:5]
	slice4 := slice[1:5]
	fmt.Println(slice1)
	fmt.Println(slice2)
	fmt.Println(slice3)
	fmt.Println(slice4)
	slice2[1] = 9
	fmt.Println(slice1)
	//新的切片和原切片共用的是一个底层数组，
	//所以当修改的时候，底层数组的值就会被改变，所以原切片的值也改变了。
	//当然对于基于数组的切片也一样的。

	//我们基于原数组或者切片创建一个新的切片后，那么新的切片的大小和容量是多少呢？这里有个公式：
	//	对于底层数组容量是k的切片slice[i:j]来说
	//	长度：j-i
	//容量:k-i

	//slice := []int{1, 2, 3, 4, 5}
	//newSlice := slice[1:2:3]
	//第3个参数   用来限定新切片的容量
	//这样我们就创建了一个长度为2-1=1，容量为3-1=2的新切片,不过第三个索引，不能超过原切片的最大索引值5。


	//slice := []int{1, 2, 3, 4, 5}
	newSlice := slice[1:3]

	newSlice=append(newSlice,10)
	fmt.Println(newSlice)
	fmt.Println(slice)

	//注意，原切片slice的第4个值也被改变了，变成了10
	//引起这种结果的原因是因为newSlice有可用的容量，不会创建新的切片来满足追加，
	//所以直接在newSlice后追加了一个元素10，因为newSlice和slice切片共用一个底层数组，所以切片slice的对应的元素值也被改变了。

	//所以一般我们在创建新切片的时候，最好要让新切片的长度和容量一样，
	//这样我们在追加操作的时候就会生成新的底层数组，和原有数组分离，
	//就不会因为共用底层数组而引起奇怪问题,因为共用数组的时候修改内容，会影响多个切片。

	//内置的append也是一个可变参数的函数，所以我们可以同时追加好几个值。
	//newSlice=append(newSlice,10,20,30)

	//还可以通过...操作符，把一个切片追加到另一个切片里。
	//slice := []int{1, 2, 3, 4, 5}
	//newSlice := slice[1:2:3]
	//
	//newSlice=append(newSlice,slice...)
	//fmt.Println(newSlice)
	//fmt.Println(slice)

	//迭代切片
	slice34 := []int{1, 2, 3, 4, 5}
	for i,v:=range slice34{
		fmt.Printf("索引:%d,值:%d\n",i,v)
	}

	//如果我们不想要索引，可以使用_来忽略它，这是Go语言的用法，很多不需要的函数等返回值，都可以忽略。
	for _,v:=range slice34{
		fmt.Printf("值:%d\n",v)
	}
	for i := 0; i < len(slice); i++ {
		fmt.Printf("值:%d\n", slice[i])
	}




}
//在函数间传递切片
//函数间以值的方式传递的时候，占用的内存非常小
//在传递复制切片的时候，其底层数组不会被复制，也不会受影响，复制只是复制的切片本身，不涉及底层数组
func Test3() {
	slice := []int{1, 2, 3, 4, 5}
	fmt.Printf("%p\n", &slice)
	modify2(slice)
	fmt.Println(slice)
}

func modify2(slice []int) {
	fmt.Printf("%p\n", &slice)
	slice[1] = 10
}
//这两个切片的地址不一样，所以可以确认切片在函数间传递是复制的
//而我们修改一个索引的值后，发现原切片的值也被修改了，说明它们共用一个底层数组。

//这也是为什么函数间传递参数，使用切片，而不是数组的原因。